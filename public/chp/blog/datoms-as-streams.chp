(let [template (load-file "public/chp/template.chp")]
  (clojure.walk/postwalk-replace
   {:template/title "Streaming Datoms with Transducers — Datom.World"
    :template/content
    (list
     [:section.blog-article
      [:div.section-inner
       [:article
        [:h1 "Streaming Datoms with Transducers"]
        [:div.blog-article-meta "Published Dec 3, 2024 · 6 minute read"]
        [:p
         "One of the quiet superpowers behind Datom.World is that every fact is a datom in an immutable stream. "
         "Because we model changes as a log of tuples, we can rebuild state anywhere — on a phone, in a WASM runtime, "
         "or across a mesh of edge nodes — as long as we can fold over the stream."]
        [:p
         "Clojure's transducers let us process those streams with almost no ceremony. "
         "In this post we will build a focused pipeline that filters datoms, transforms them into indexed entities, "
         "and materializes a snapshot ready for UI consumption."]
        [:h2 "From tuples to pipelines"]
        [:p
         "Start with a handful of datoms. Each tuple follows the `[entity attribute value tx-id context]` shape, "
         "so we can describe anything from identities to permissions. "
         "Transducers let us chain pure steps over that stream without creating intermediate collections."]
        [:pre
         [:code {:class "language-clojure"}
"(ns datomworld.blog.streams
  (:require [clojure.core.reducers :as r]
            [clojure.set :as set]))

(defn stream->entities
  \"Extract entity/type pairs from the datom log.\"
  [datoms]
  (sequence
   (comp
    (filter #(= (:a %) :entity/type))
    (map (juxt :e :v)))
   datoms))

(defn materialize-snapshot
  \"Build an entity map indexed by :db/id.\"
  [datoms]
  (into {}
        (map (fn [[entity type]] [entity {:db/id entity
                                          :entity/type type}]))
        (stream->entities datoms)))

(defn transduce-datoms
  \"Apply any transducer to the datom stream in a single pass.\"
  [xf datoms]
  (transduce xf conj datoms))"]]
        [:p
         "Because transducers are just functions that describe composition, we can reuse the same building blocks "
         "on the edge, on the desktop, or anywhere else we ship the stream."]
        [:h2 "Entangling facts at the edge"]
        [:p
         "With the helper in place we can materialize a snapshot for a UI or analytics job. "
         "Here is a practical sequence that derives entity metadata while counting assertions in a single pass."]
        [:pre
         [:code {:class "language-clojure"}
"(def datoms
  [{:e 1 :a :entity/type :v :person :tx 1001 :c :alpha}
   {:e 1 :a :person/name :v \"Ada\" :tx 1001 :c :alpha}
   {:e 2 :a :entity/type :v :device :tx 1002 :c :beta}
   {:e 2 :a :device/os :v :ios :tx 1002 :c :beta}])

(def entity-types
  (materialize-snapshot datoms))

(def assertion-count
  (transduce (map (constantly 1)) + datoms))"]]
        [:p
         "Using a pure transducer pipeline keeps our runtime deterministic. "
         "No matter where the stream lands, the tuple log can be folded into the same shape, "
         "so conflict resolution becomes another transformation instead of bespoke state management."]
        [:h2 "Where to take it next"]
        [:ol
         [:li "Compose filters for permission-aware replication flows."]
         [:li "Emit on-change notifications by threading transducers into `core.async` channels."]
         [:li "Ship the same pipelines to a WASM runtime for offline-first experiences."]]
        [:p
         "This is the style of Clojure you will find throughout Datom.World — declarative, stream-native, and "
         "easy to reason about in production."]]]])}
   template))
