(let [template (load-file "public/chp/template.chp")]
  (clojure.walk/postwalk-replace
   {:template/title "Datom.World — Technical Blog"
    :template/content
    (list
     [:section.blog-list
      [:div.section-inner
       [:div.blog-grid
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 18, 2025"]
          [:span "8 min read"]]
         [:h2 [:a {:href "/blog/datom-representation-performance.chp"} "Datom Representation and the Hidden Performance Cost"]]
         [:p
          "Datoms look simple: [e a v t c]. Fixed-size tuple, right? Wrong. The tuple is fixed-size, but its elements aren't. Variable-size entities, attributes, and values create parsing overhead, cache inefficiency, and compression challenges. How DaoDB balances semantic flexibility with execution performance through interning, hybrid storage, and columnar encoding."]
         [:a {:href "/blog/datom-representation-performance.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 18, 2025"]
          [:span "12 min read"]]
         [:h2 [:a {:href "/blog/ai-data-crisis.chp"} "The Coming AI Data Crisis — and Why Datom.world Exists"]]
         [:p
          "Andrew Ng highlighted a crisis: AI agents are getting smarter faster than data infrastructure can keep up. SaaS vendors charge thousands for API access to your own data. The problem is structural—silos vs streams. Datom.world solves this with local-first datom streams: you own your data, apps are interpreters, agents become first-class peers. The architecture itself must change."]
         [:a {:href "/blog/ai-data-crisis.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 18, 2025"]
          [:span "18 min read"]]
         [:h2 [:a {:href "/blog/pi-calculus-rqm-interaction.chp"} "π-Calculus, RQM, and the Primacy of Interaction"]]
         [:p
          "Relational Quantum Mechanics says reality is a network of interactions, not independent facts. The π-calculus says computation is message-passing, not state. Are these the same insight? Yes. State-first vs interaction-first paradigms. Properties emerge from measurement, processes are their communication behavior, datoms record interaction histories. DaoDB implements both π-calculus and RQM—same architecture, different perspectives."]
         [:a {:href "/blog/pi-calculus-rqm-interaction.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 17, 2025"]
          [:span "20 min read"]]
         [:h2 [:a {:href "/blog/datom-world-wave-function-collapse.chp"} "Datom.World and the Collapse of the Wave Function"]]
         [:p
          "DaoDB is a local-first distributed tuple store. When devices sync, conflicts arise—like wave function collapse in quantum mechanics. Relational Quantum Mechanics says there's no global state, only local states relative to observers. DaoDB implements this: conflicts are superposition, sync is measurement, CRDT merge is entanglement, retrocausality is reconciling histories. Distributed databases are quantum systems."]
         [:a {:href "/blog/datom-world-wave-function-collapse.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 17, 2025"]
          [:span "16 min read"]]
         [:h2 [:a {:href "/blog/what-makes-datalog-datalog.chp"} "What Makes Datalog Datalog: Semantics, Not Syntax"]]
         [:p
          "Datomic uses EDN syntax. Prolog uses predicates. SQL uses WITH RECURSIVE. Are they all actually Datalog? Yes—because Datalog is defined by its evaluation model, not its surface representation. Horn clauses, fixed-point semantics, guaranteed termination, stratified negation. Syntax is just clothing. Semantics are the soul."]
         [:a {:href "/blog/what-makes-datalog-datalog.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 16, 2025"]
          [:span "18 min read"]]
         [:h2 [:a {:href "/blog/datalog-compiler-infrastructure.chp"} "Datalog as Compiler Infrastructure: Why DaoDB Makes Every Optimization Queryable"]]
         [:p
          "Traditional compilers walk ASTs with limited context. But what if the entire program was a queryable database? When ASTs are datoms in DaoDB, every optimization becomes a Datalog query—whole-program reasoning, composable analyses, incremental compilation, and user-programmable optimizations. Compilation as database query."]
         [:a {:href "/blog/datalog-compiler-infrastructure.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 16, 2025"]
          [:span "14 min read"]]
         [:h2 [:a {:href "/blog/ast-datom-streams-bytecode-performance.chp"} "AST Datom Streams: Bytecode Performance with Semantic Preservation"]]
         [:p
          "Bytecode is fast but erases semantics. AST interpretation is slow but preserves meaning. This is considered a fundamental trade-off. But what if AST-as-datom-streams blurs the line? Compile AST datoms to execution streams via Datalog—get sequential access performance while preserving full queryability. The false dichotomy revealed."]
         [:a {:href "/blog/ast-datom-streams-bytecode-performance.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 16, 2025"]
          [:span "11 min read"]]
         [:h2 [:a {:href "/blog/many-syntaxes-one-ast.chp"} "Many Syntaxes, One AST: The Non-Deterministic Rendering Problem"]]
         [:p
          "A single Universal AST can be rendered as multiple valid syntaxes. List comprehension or for-loop? Lambda or method reference? When the AST is canonical and syntax is a view, how does the renderer choose? Five solutions and a provocative question: is syntax loss a feature, not a bug?"]
         [:a {:href "/blog/many-syntaxes-one-ast.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 16, 2025"]
          [:span "13 min read"]]
         [:h2 [:a {:href "/blog/universal-ast-vs-assembly.chp"} "Universal AST vs Assembly: High-Level Semantics in Low-Level Form"]]
         [:p
          "The Universal AST as datom streams looks like assembly code. Flat. Verbose. Low-level. But assembly optimizes for execution, while the AST optimizes for semantic preservation. One sits at the bottom of the execution stack. The other sits at the top of the semantic stack. Understanding the inversion."]
         [:a {:href "/blog/universal-ast-vs-assembly.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 16, 2025"]
          [:span "16 min read"]]
         [:h2 [:a {:href "/blog/semantic-impedance-mismatch.chp"} "The Semantic Impedance Mismatch: Can a Universal AST Really Work?"]]
         [:p
          "OOP has classes. Functional languages don't. How can they share a common AST? The answer: most differences are encoding, not semantics. Classes are closures. Exceptions are result types. The Universal AST represents the semantic core, not syntactic union. A deep dive into making the impossible possible."]
         [:a {:href "/blog/semantic-impedance-mismatch.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 16, 2025"]
          [:span "14 min read"]]
         [:h2 [:a {:href "/blog/ide-edits-ast-not-text.chp"} "When the IDE Edits AST, Not Text"]]
         [:p
          "What happens when you build an IDE where you edit the AST directly and text is just a view? Syntax becomes a preference. Refactoring becomes precise. Time-travel is built in. And code becomes queryable as a database. The implications of AST-native editing."]
         [:a {:href "/blog/ide-edits-ast-not-text.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 15, 2025"]
          [:span "12 min read"]]
         [:h2 [:a {:href "/blog/ast-higher-dimensional-datom-streams.chp"} "AST as Higher Dimensional Construction of Datom Streams"]]
         [:p
          "Beyond trees: how ASTs become multidimensional streams of datoms flowing through structure, time, types, languages, and execution states. Why continuations are transactions, how to query across dimensions, and what it means for code to be a living stream of facts."]
         [:a {:href "/blog/ast-higher-dimensional-datom-streams.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 15, 2025"]
          [:span "15 min read"]]
         [:h2 [:a {:href "/blog/yin-vm-ast-chinese-characters.chp"} "Yin.vm: Chinese Characters for Programming Languages"]]
         [:p
          "How Chinese characters inspired a universal semantic AST. Just as 水 means \"water\" in both Mandarin and Cantonese despite different pronunciations, Yin.vm's canonical AST preserves semantics across Python, C++, and Clojure—enabling bijective translation, mobile code, and queryable meaning."]
         [:a {:href "/blog/yin-vm-ast-chinese-characters.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 14, 2025"]
          [:span "22 min read"]]
         [:h2 [:a {:href "/blog/structure-vs-interpretation.chp"} "Structure vs Interpretation: Why Schemas/Ontologies Are Secret Interpreters"]]
         [:p
          "Where does meaning live? In data structure or in interpretation? Why schemas are interpreters in disguise, what biology teaches us about bootstrapping semantics, and how correlation becomes causation when systems learn to exploit it."]
         [:a {:href "/blog/structure-vs-interpretation.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Nov 5, 2025"]
          [:span "18 min read"]]
         [:h2 [:a {:href "/blog/unitarity-and-communication-limits.chp"} "Unitarity, π-Calculus, and the Cosmic Speed Limit"]]
         [:p
          "Why the universe is a stream-native continuation system. How unitarity + π-calculus prove communication must have finite speed, why quantum collapse is local buffer fragmentation, and how the multiverse emerges from distributed interpreters."]
         [:a {:href "/blog/unitarity-and-communication-limits.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Oct 29, 2025"]
          [:span "10 min read"]]
         [:h2 [:a {:href "/blog/code-entropy-evolution.chp"} "Code as Entropy: Why Good Software Evolves, Not Designed"]]
         [:p
          "Good code isn't designed—it evolves toward low-entropy structures. On cohesion, coupling, test-induced brittleness, and why all documentation decays."]
         [:a {:href "/blog/code-entropy-evolution.chp"} "Read the article →"]]
        [:article.blog-card
         [:div.blog-meta
          [:span "Dec 3, 2024"]
          [:span "6 min read"]]
         [:h2 [:a {:href "/blog/datoms-as-streams.chp"} "Streaming Datoms with Transducers"]]
         [:p
          "How we combine datom streams with transducers to build resilient, composable dataflows across the network edge."]
         [:a {:href "/blog/datoms-as-streams.chp"} "Read the article →"]]]]])}
   template))
