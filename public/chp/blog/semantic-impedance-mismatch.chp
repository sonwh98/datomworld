(let [template (load-file "public/chp/template.chp")]
  (clojure.walk/postwalk-replace
   {:template/title "The Semantic Impedance Mismatch: Can a Universal AST Really Work? - Datom.World"
    :template/content
    (list
     [:section.blog-article
      [:div.section-inner
       [:article
        [:h1 "The Semantic Impedance Mismatch: Can a Universal AST Really Work?"]
        [:div.blog-article-meta "Published Nov 16, 2025 · 16 minute read"]

        [:h2 "The Challenge"]
        [:p
         "Object-oriented languages have classes and objects. Functional languages have no such concept. Instead, they have higher-order functions and closures. Procedural languages have goto. Modern languages forbid it. Some languages have exceptions. Others use result types. Some have null. Others make it impossible."]
        [:p
         [:strong "How can languages with fundamentally different semantic primitives share a common Universal AST?"] ""]
        [:p
         "This is the " [:strong "semantic impedance mismatch"] ". It's the core challenge that makes a Universal Semantic AST seem impossible. If Java has " [:code "class"] " and Clojure doesn't, what AST node represents a Java class when translated to Clojure?"]

        [:h2 "The False Premise: Languages Are Different"]
        [:p
         "Here's the key insight: " [:strong "the semantic differences are smaller than they appear"] "."]
        [:p
         "Object-oriented programming and functional programming aren't " [:em "fundamentally"] " different. They're " [:strong "different encodings of the same computational concepts"] "."]
        [:p
         "A class is:"]
        [:ul.bulleted
         [:li "A collection of data (fields)"]
         [:li "A collection of operations on that data (methods)"]
         [:li "A way to create instances (constructor)"]
         [:li "A namespace for those operations"]]
        [:p
         "A closure in a functional language is:"]
        [:ul.bulleted
         [:li "Captured data (closed-over variables)"]
         [:li "Operations on that data (the function body)"]
         [:li "A way to create instances (call the closure-returning function)"]
         [:li "Scope for those operations"]]
        [:p
         [:strong "They're the same concept."] " Different syntax. Different terminology. But semantically equivalent."]

        [:h2 "Strategy 1: Translate to a Common Semantic Core"]
        [:p
         "The Universal AST doesn't need to represent " [:em "every language construct"] ". It needs to represent the " [:strong "semantic primitives"] " that all languages share."]

        [:h3 "The Core Semantic Primitives"]
        [:p
         "What are the irreducible semantic concepts that " [:em "all"] " general-purpose languages must have?"]
        [:ul.bulleted
         [:li [:strong "Data"] " (values, aggregates, references)"]
         [:li [:strong "Computation"] " (functions, lambdas, operations)"]
         [:li [:strong "Control flow"] " (sequencing, branching, looping)"]
         [:li [:strong "Scope"] " (binding, closure, namespaces)"]
         [:li [:strong "Effects"] " (I/O, mutation, exceptions)"]]
        [:p
         "Every language has these. The " [:strong "Universal AST represents these primitives"] ". Language-specific constructs are " [:strong "compiled down to these primitives"] "."]

        [:h3 "Example: Class → Semantic Core"]
        [:p
         "A Java class:"]
        [:pre [:code
               "class Counter {
    private int count = 0;

    public void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}"]]
        [:p
         "Translates to the Universal AST as:"]
        [:pre [:code
               ";; Universal AST (datoms)
[node-1 :ast/type :data-with-operations]
[node-1 :ast/name \"Counter\"]

;; Constructor: returns instance
[node-1 :ast/constructor constructor-1]
[constructor-1 :ast/type :function]
[constructor-1 :ast/returns instance-1]

;; Data: mutable state
[instance-1 :ast/data [state-1]]
[state-1 :ast/name \"count\"]
[state-1 :ast/type-declared :int]
[state-1 :ast/mutability :mutable]
[state-1 :ast/initial-value 0]

;; Operations on the data
[instance-1 :ast/operations [op-1 op-2]]
[op-1 :ast/type :function]
[op-1 :ast/name \"increment\"]
[op-1 :ast/mutates state-1]

[op-2 :ast/type :function]
[op-2 :ast/name \"getCount\"]
[op-2 :ast/reads state-1]
[op-2 :ast/returns-type :int]"]]
        [:p
         "The Universal AST doesn't have a " [:code ":class"] " node. It represents the semantic primitive " [:code ":data-with-operations"] ":"]
        [:ul.bulleted
         [:li "A constructor function that creates instances"]
         [:li "Mutable state (" [:code "count"] ")"]
         [:li "Operations that access/mutate that state (" [:code "increment"] ", " [:code "getCount"] ")"]]
        [:p
         "This Universal AST can be " [:strong "rendered"] " as either Java or Clojure:"]
        [:pre [:code
               ";; Clojure rendering of the same AST
(defn make-counter []
  (let [count (atom 0)]
    {:increment (fn [] (swap! count inc))
     :get-count (fn [] @count)}))"]]
        [:p
         "Same AST. Different renderings. The Universal AST is the " [:strong "canonical code"] ". Java and Clojure are just " [:strong "views"] "."]
        [:p
         "This is the " [:strong "semantic meaning"] " of a class. The Universal AST preserves it without needing an OOP-specific construct."]

        [:h3 "Example: Higher-Order Function → Semantic Core"]
        [:p
         "A Haskell higher-order function:"]
        [:pre [:code
               "map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs"]]
        [:p
         "Translates to Universal AST:"]
        [:pre [:code
               ";; Universal AST (datoms)
[node-1 :ast/type :map-operation]
[node-1 :ast/name \"map\"]

;; Input: transform function
[node-1 :ast/params [param-1 param-2]]
[param-1 :ast/name \"f\"]
[param-1 :ast/type-declared :function]

;; Input: collection
[param-2 :ast/name \"coll\"]
[param-2 :ast/type-declared :collection]

;; Semantics: apply f to each element
[node-1 :ast/operation :apply-to-each]
[node-1 :ast/function param-1]
[node-1 :ast/collection param-2]
[node-1 :ast/returns-type :collection]

;; Control flow
[node-1 :ast/iteration-strategy :recursive]
[node-1 :ast/base-case empty-check]
[node-1 :ast/recursive-case apply-and-recur]"]]
        [:p
         "The Universal AST doesn't need Haskell's pattern matching or lazy lists. It represents the semantic primitive " [:code ":map-operation"] ":"]
        [:ul.bulleted
         [:li "A function that transforms elements (" [:code "f"] ")"]
         [:li "A collection to iterate over (" [:code "coll"] ")"]
         [:li "An iteration strategy (recursive in this case)"]
         [:li "Base case and recursive case"]]
        [:p
         "This can be rendered as Haskell pattern matching, Python list comprehension, or Java streams. Same semantics. Different encoding."]

        [:h2 "Strategy 2: Semantic Equivalence Classes"]
        [:p
         "Some constructs don't compile down cleanly. They're " [:strong "semantic equivalence classes"] ". The Universal AST marks them as equivalent."]

        [:h3 "Example: Error Handling"]
        [:p
         "Java has exceptions:"]
        [:pre [:code
               "try {
    riskyOperation();
} catch (IOException e) {
    handleError(e);
}"]]
        [:p
         "Rust has Result types:"]
        [:pre [:code
               "match risky_operation() {
    Ok(value) => process(value),
    Err(e) => handle_error(e),
}"]]
        [:p
         "Semantically, both are:"]
        [:ul.bulleted
         [:li "An operation that might fail"]
         [:li "A success path"]
         [:li "A failure path"]]
        [:p
         "The Universal AST represents this as:"]
        [:pre [:code
               "[node-1 :ast/type :error-handling]
[node-1 :ast/operation risky-op]
[node-1 :ast/success-path success-handler]
[node-1 :ast/failure-path error-handler]
[node-1 :ast/encoding :exception]  ; or :result-type"]]
        [:p
         "When translating Java → Rust, the AST transforms " [:code ":encoding :exception"] " to " [:code ":encoding :result-type"] ". The " [:strong "semantic structure is preserved"] "."]

        [:h3 "Equivalence Class: Iteration"]
        [:p
         "Different languages have different iteration primitives:"]
        [:ul.bulleted
         [:li "C: " [:code "for (int i = 0; i < n; i++)"] ""]
         [:li "Python: " [:code "for item in items:"] ""]
         [:li "Haskell: " [:code "map f xs"] ""]
         [:li "Java: " [:code "stream().map(f).collect()"] ""]]
        [:p
         "All are in the " [:strong "\"map over collection\" equivalence class"] ". The Universal AST represents:"]
        [:pre [:code
               "[node-1 :ast/type :map-operation]
[node-1 :ast/function transform]
[node-1 :ast/collection items]
[node-1 :ast/encoding :for-loop]  ; or :list-comp, :map-function, :stream"]]
        [:p
         "The " [:code ":encoding"] " attribute preserves how the source language expressed it. The semantic type " [:code ":map-operation"] " enables cross-language translation."]

        [:h2 "Strategy 3: Lossy Translation with Annotations"]
        [:p
         "Some constructs " [:strong "cannot be perfectly translated"] ". The Universal AST must be honest about this."]

        [:h3 "Example: Goto"]
        [:p
         "C has " [:code "goto"] ". Most modern languages forbid it. You can't translate arbitrary " [:code "goto"] " to structured control flow without potentially changing semantics."]
        [:p
         "The Universal AST handles this with " [:strong "annotations"] ":"]
        [:pre [:code
               "[node-1 :ast/type :control-flow]
[node-1 :ast/primitive :goto]
[node-1 :ast/target label-5]
[node-1 :ast/translatable? false]
[node-1 :ast/fallback :exception]  ; Throw \"unsupported\" if translated"]]
        [:p
         "The AST " [:strong "preserves the semantic intent"] " (unconditional jump to label) but marks it as non-translatable to languages without goto. Attempting to translate C with goto to Python would fail with a clear error."]
        [:p
         "This is " [:strong "honest failure"] ", not silent corruption."]

        [:h3 "Example: Multiple Inheritance"]
        [:p
         "C++ allows multiple inheritance. Java doesn't. The Universal AST can represent it:"]
        [:pre [:code
               "[class-1 :ast/type :class]
[class-1 :ast/inherits [parent-1 parent-2]]
[class-1 :ast/multiple-inheritance? true]"]]
        [:p
         "But when translating to Java, the compiler must either:"]
        [:ul.bulleted
         [:li "Flatten to interfaces (lossy but functional)"]
         [:li "Fail with an error (honest)"]
         [:li "Use composition pattern (semantic transformation)"]]
        [:p
         "The Universal AST " [:strong "makes the loss explicit"] ". It doesn't silently break semantics."]

        [:h2 "Strategy 4: Gradual Typing as a Model"]
        [:p
         "Gradual typing shows how to handle " [:strong "partial information"] ". Some parts of the program are fully typed. Some are not. The system handles both."]
        [:p
         "The Universal AST does the same for " [:strong "partial semantic coverage"] ":"]
        [:ul.bulleted
         [:li "Some AST nodes map cleanly across all languages (functions, variables, arithmetic)"]
         [:li "Some map to equivalence classes (error handling, iteration)"]
         [:li "Some are language-specific and marked as such (goto, multiple inheritance)"]
         [:li "The system " [:strong "tracks what's translatable and what's not"] ""]]
        [:p
         "Just as gradually-typed code has " [:code "any"] " types where full typing isn't possible, the Universal AST has " [:code ":ast/language-specific true"] " for constructs that don't generalize."]

        [:h2 "Strategy 5: The 80/20 Rule"]
        [:p
         "The Universal AST doesn't need to handle " [:em "all"] " language features. It needs to handle " [:strong "the 80% that matter"] "."]
        [:p
         "Most real-world code uses:"]
        [:ul.bulleted
         [:li "Functions and data structures"]
         [:li "Conditionals and loops"]
         [:li "Variable binding and scope"]
         [:li "Basic I/O and effects"]]
        [:p
         "These " [:strong "translate cleanly"] " across languages. The 20% of esoteric features (goto, continuations, macros, multiple inheritance) can be:"]
        [:ul.bulleted
         [:li "Marked as non-translatable"]
         [:li "Translated with explicit loss (with warnings)"]
         [:li "Handled by language-specific plugins"]]
        [:p
         "A Universal AST that covers 80% of code is still " [:strong "immensely useful"] "."]

        [:h2 "What About Truly Incompatible Semantics?"]
        [:p
         "Some differences are " [:strong "truly semantic"] ":"]

        [:h3 "Lazy vs Eager Evaluation"]
        [:p
         "Haskell is lazy by default. Python is eager. These affect " [:strong "when"] " code runs, which can change semantics."]
        [:p
         "The Universal AST represents this in the " [:strong "execution dimension"] ":"]
        [:pre [:code
               "[node-1 :ast/type :function-call]
[node-1 :exec/evaluation-strategy :lazy]  ; or :eager
[node-1 :exec/memoized? true]"]]
        [:p
         "When translating Haskell → Python, the compiler can:"]
        [:ul.bulleted
         [:li "Wrap lazy values in thunks (preserve laziness)"]
         [:li "Force evaluation at translation time (change semantics but warn)"]
         [:li "Fail translation (honest about incompatibility)"]]

        [:h3 "Mutability Guarantees"]
        [:p
         "Rust enforces memory safety through ownership. Clojure enforces immutability. C allows arbitrary mutation."]
        [:p
         "The Universal AST tracks this:"]
        [:pre [:code
               "[node-1 :ast/type :binding]
[node-1 :ast/mutability :immutable]  ; or :mutable, :owned, :borrowed
[node-1 :ast/ownership-semantics :rust-borrow]"]]
        [:p
         "Translating Rust → C loses the ownership guarantees. The AST " [:strong "makes this explicit"] ". It doesn't pretend the guarantees transfer."]

        [:h2 "The Core Principle: Semantic Honesty"]
        [:p
         "The Universal AST must be " [:strong "semantically honest"] ":"]
        [:ol
         [:li [:strong "Preserve what can be preserved"] " (core primitives)"]
         [:li [:strong "Translate equivalence classes"] " (error handling, iteration)"]
         [:li [:strong "Mark language-specific features"] " (goto, multiple inheritance)"]
         [:li [:strong "Fail loudly when translation loses semantics"] " (lazy → eager without warning)"]
         [:li [:strong "Document the loss"] " (\"This translation changes evaluation order\")"]]
        [:p
         "This is better than pretending all languages are the same. " [:strong "They're not"] ". But they're more similar than different, and the Universal AST exploits that similarity while being honest about the differences."]

        [:h2 "Practical Example: OOP Class → Functional Code"]
        [:p
         "Let's walk through a real translation to see these strategies in action."]
        [:p
         "Java:"]
        [:pre [:code
               "class BankAccount {
    private double balance;

    public BankAccount(double initial) {
        this.balance = initial;
    }

    public void deposit(double amount) {
        balance += amount;
    }

    public boolean withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            return true;
        }
        return false;
    }
}"]]
        [:p
         "Universal AST (simplified):"]
        [:pre [:code
               "[class-1 :ast/type :data-with-operations]
[class-1 :ast/data [balance]]
[class-1 :ast/operations [deposit withdraw]]
[class-1 :ast/constructor init-balance]
[class-1 :ast/state-semantics :mutable]
[class-1 :ast/encoding :class]"]]
        [:p
         "Clojure (translated):"]
        [:pre [:code
               "(defn make-bank-account [initial-balance]
  (let [balance (atom initial-balance)]
    {:deposit (fn [amount]
                (swap! balance + amount))
     :withdraw (fn [amount]
                 (if (>= @balance amount)
                   (do (swap! balance - amount)
                       true)
                   false))
     :get-balance (fn [] @balance)}))"]]
        [:p
         "What happened:"]
        [:ul.bulleted
         [:li [:code ":ast/type :data-with-operations"] " → closure with methods"]
         [:li [:code ":ast/state-semantics :mutable"] " → " [:code "atom"] " (mutable reference)"]
         [:li [:code ":ast/constructor"] " → function that returns the data structure"]
         [:li "Private field → closure-captured binding"]
         [:li "Methods → functions in the returned map"]]
        [:p
         [:strong "Semantic preservation"] ": Both versions have encapsulated mutable state with controlled access. The " [:em "concept"] " translates perfectly. Only the " [:em "encoding"] " changes."]

        [:h2 "Conclusion: Semantic Core, Not Syntactic Union"]
        [:p
         "A Universal AST is possible because:"]
        [:ol
         [:li [:strong "Most language differences are encoding, not semantics"] " (classes ≈ closures)"]
         [:li [:strong "Semantic primitives are shared"] " (data, computation, control flow, scope, effects)"]
         [:li [:strong "Equivalence classes handle variations"] " (exceptions ≈ result types)"]
         [:li [:strong "Lossy translations are marked explicitly"] " (lazy → eager with warning)"]
         [:li [:strong "Language-specific features are isolated"] " (goto marked non-translatable)"]]
        [:p
         "The Universal AST is not a " [:strong "syntactic union"] " of all languages. It's a " [:strong "semantic core"] " that captures the essential meaning while being honest about what cannot be preserved."]
        [:p
         "This is why the AST must be " [:strong "canonical"] ". When the AST is the source of truth, languages become " [:strong "views"] " over that semantic core. The question isn't \"How do we translate a Java class to Clojure?\" It's \"How do we " [:em "render"] " this semantic construct (data-with-operations) as Java syntax vs Clojure syntax?\""]
        [:p
         "The impedance mismatch isn't eliminated. But it's " [:strong "made explicit, queryable, and manageable"] "."]

        [:p [:strong "Learn more:"]]
        [:ul.bulleted
         [:li [:a {:href "/blog/yin-vm-ast-chinese-characters.chp"} "Yin.vm: Chinese Characters for Programming Languages"] " (the Universal Semantic AST)"]
         [:li [:a {:href "/blog/ast-higher-dimensional-datom-streams.chp"} "AST as Higher Dimensional Construction of Datom Streams"] " (how ASTs are materialized views)"]
         [:li [:a {:href "/dao-db.chp"} "DaoDB"] " (the Datalog database powering queryable ASTs)"]
         [:li [:a {:href "/yin.chp"} "Yin VM Documentation"] " (technical deep dive)"]]]]])}
   template))
