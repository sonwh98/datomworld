#:blog{:title
       "Structure vs Interpretation: Why Schemas/Ontologies Are Secret Interpreters",
       :date #inst "2025-11-14T00:00:00.000-00:00",
       :abstract
       [:p
        "I met Pete Chapman, CEO of "
        [:a {:href "https://firstcognition.com/"} "FirstCognition"]
        ", at "
        [:a
         {:href
          "https://www.thoughtworks.com/about-us/events/xconf/2025/vietnam"}
         "Thoughtworks XConf Vietnam 2025"]
        ". What struck me was how aligned our visions are. Both FirstCognition and "
        "Datom.world are trying to solve the same fundamental problem: make data programmable at a semantic level, "
        "not trapped in fragmented application silos."],
       :content
       (list
        [:section.blog-article
         [:div.section-inner
          [:article
           [:h1
            "Structure vs Interpretation: Why Schemas/Ontologies Are Secret Interpreters"]
           [:div.blog-article-meta
            "Published Nov 14, 2025 · 22 minute read"]
           [:p
            "I met Pete Chapman, CEO of "
            [:a {:href "https://firstcognition.com/"} "FirstCognition"]
            ", at "
            [:a
             {:href
              "https://www.thoughtworks.com/about-us/events/xconf/2025/vietnam"}
             "Thoughtworks XConf Vietnam 2025"]
            ". What struck me was how aligned our visions are. Both FirstCognition and "
            "Datom.world are trying to solve the same fundamental problem: make data programmable at a semantic level, "
            "not trapped in fragmented application silos."]
           [:p
            "But we diverge on a philosophical question: "
            [:strong "where does meaning live?"]
            " Does it reside in the structure of data itself, or does it emerge only through interpretation?"]
           [:p
            "FirstCognition believes that with the right schemas and ontologies, data can carry its own meaning. "
            "Datom.world believes data is syntax (always) and meaning emerges only when an interpreter observes it."]
           [:p
            "Consider what happens when you use a type system or ontology. The type checker evaluates logical constraints. "
            "The reasoning engine performs inference over RDF triples. Even when a human reads a schema and understands "
            "what the fields mean, "
            [:em "that understanding is interpretation"]
            ". The interpreter might be "
            "software (type checker, reasoner) or wetware (human mind), but it's always there, always required, "
            "always performing the work that transforms syntax into semantics."]
           [:p
            "This isn't academic philosophy. It determines whether your system can handle semantic evolution, "
            "multiple interpretations, distributed agents, and AI collaboration. Get it wrong, and you've built "
            "a beautiful prison. Get it right, and you've built a living system."]
           [:p
            "Consider a simple example: a user profile with a schema "
            [:code "{name: String, age: Int}"]
            ". "
            "The schema tells you the shape, but what does "
            [:code "age"]
            " actually mean? Years since birth? "
            "Months? Age at signup, or current age calculated dynamically? Age in human years, or dog years if "
            "this is a pet app? The schema cannot tell you. Only an interpreter—your application code, a validator, "
            "or even your brain as you read the schema—imposes that meaning. The structure is just bytes arranged "
            "in a pattern. Semantics require interpretation."]
           [:h2 "Structure as Meaning"]
           [:p
            "The first approach assumes "
            [:strong "meaning lives in the structure of data itself"]
            ". "
            "If you structure data correctly, the system can compute on it without special semantics. "
            "This is inspired by type theory, structuralism, and knowledge graphs."]
           [:p
            "The promise is elegant: a universal structural layer gives predictability, low cognitive load, "
            "and shared ontology. Users can model their domain, and the structure captures the semantics."]
           [:p
            "But here's the problem: "
            [:strong "structure is just syntax"]
            ". A structure (JSON, EDN, "
            "a typed schema, a graph) is just shape. Shape doesn't equal meaning."]
           [:p
            "A structure can encode a user profile, a molecule, political alliances, or a Clojure AST. "
            "But the structure itself doesn't know what it's encoding. Without something that interprets "
            "the shape, the shape is meaningless."]
           [:h3 "Interpretation as Meaning (The Agent Approach)"]
           [:p
            "Datom.world takes a different approach: "
            [:strong "semantics are external"]
            ". "
            "Meaning emerges from interpreters: explicit, dynamic, migratable agents. Everything is a stream; "
            "everything is a "
            [:a {:href "/faq.chp"} "continuation"]
            ". Data is just syntax until an interpreter observes a local slice "
            "and imposes meaning."]
           [:p
            "This handles ambiguity, evolution, and multiplicity of meaning naturally. Multiple interpreters "
            "can observe the same data stream and extract different semantics. Crucial in multi-agent systems "
            "and AI environments where no single interpretation suffices."]
           [:h2
            "Type Systems Are Logical Systems That Require Interpreters"]
           [:p
            "The schema approach often points to type systems as proof that structure can carry semantics. "
            "But "
            [:strong
             "type systems are formal logical systems, and logical systems require interpreters"]
            "."]
           [:p
            "Through the "
            [:a
             {:href
              "https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence"}
             "Curry–Howard correspondence"]
            ", we know that types correspond to logical propositions, "
            "and type checking corresponds to proof verification. A type system expresses constraints as logical predicates:"]
           [:ul.bulleted
            [:li
             [:code "isInteger(x)"]
             " (a logical constraint about "
             [:code "x"]
             ")"]
            [:li
             [:code "hasProperty(obj, \"email\")"]
             " (a constraint about object structure)"]
            [:li
             [:code "satisfiesContract(fn, A → B)"]
             " (a constraint about function behavior)"]]
           [:p
            "These constraints don't evaluate themselves. They require "
            [:strong "an interpreter"]
            " (the type checker). The type checker interprets both the logical constraints and the program terms to produce semantic judgments:"]
           [:ol
            [:li "Reads the type annotations (logical propositions)"]
            [:li
             "Reads the program terms (expressions, values, structures)"]
            [:li "Evaluates whether the terms satisfy the constraints"]
            [:li "Returns a judgment (well-typed or type error)"]]
           [:p
            "This is interpretation. The type checker "
            [:em "interprets"]
            " a formal logical system "
            "to determine whether programs are valid."]
           [:p
            "Different type systems use different logical foundations:"]
           [:ul.bulleted
            [:li "ML-family → Hindley–Milner → second-order logic"]
            [:li
             "Haskell → System Fω → higher-order logic with constraints"]
            [:li
             "Agda/Coq → dependent types → constructive type theory"]
            [:li
             "Rust → borrow checker → affine types and region calculus"]]
           [:p
            "The more expressive your type system, the more complex your interpreter becomes. "
            "Dependent types require a full theorem prover. Linear types require tracking resource usage. "
            "You haven't eliminated interpretation. You've moved it into an increasingly sophisticated logical evaluator."]
           [:p
            "Ontologies follow the same pattern. OWL predicates like "
            [:code "Person subClassOf Animal"]
            " or "
            [:code "hasParent domain Person"]
            " require an inference engine (reasoner) to evaluate them. "
            "The reasoner interprets these logical constraints to derive semantic conclusions. Same mechanism, different syntax."]
           [:p
            "There is no escape. "
            [:strong
             "Any time you say \"we just need a shared schema/ontology,\" "
             "you've secretly signed up to write a logical interpreter"]
            " (even if you don't call it that). "
            "The interpreter might run in a type checker, a reasoner, a validator, or in the mind of "
            "a human reader. But it's always there, performing the act of interpretation that creates meaning."]
           [:h2 "The DNA-Ribosome Bootstrap"]
           [:p
            "If interpreters are always required, how do they originate? This seems circular: "
            "you need an interpreter to create meaning, but interpreters themselves are structures that need interpretation. "
            "How does the first interpreter come to exist? Biology shows us the answer."]
           [:p
            "Consider a biological analogy"
            [:sup [:a {:href "#footnote-dna"} "†"]]
            ". DNA is structure (syntax). Ribosomes are interpreters (semantics). "
            "Yet ribosomes are built from DNA, and DNA is useless without ribosomes."]
           [:p
            "This creates a paradox if you assume structure and interpreter must originate together. "
            "But they don't. They evolved independently (just chemicals with shape, just catalytic surfaces) until "
            "one accidentally amplified the other."]
           [:p
            [:strong
             "Structure and interpreter evolved independently, but by coincidence, an interpreter "
             "happened to be able to make use of an existing structure to encode itself"]
            "."]
           [:p
            "Once that feedback loop formed, semantics became real. Codons \"mean\" amino acids. "
            "Sequences \"mean\" proteins. But that meaning is not intrinsic to the molecules. "
            "It arises from the mapping enforced by the interpreter."]
           [:p
            "Nothing chemical about AUG means \"start codon.\" It means \"start\" only because ribosomes "
            "interpret it that way. "
            [:strong
             "Meaning = stable correlation that persists through time"]
            "."]
           [:h2 "Correlation, Causation, and Exploitation"]
           [:p
            "This connects to a deeper principle: "
            [:strong
             "persistent correlation becomes a causal signal when a system can exploit it"]
            "."]
           [:p
            "Before the genetic code existed, patterns in RNA correlated with certain folds. "
            "Some peptides correlated with stabilizing strands. None of this was causal, just regularity."]
           [:p
            "Then a molecule arose capable of amplifying these regularities. The correlation loop closed. "
            "The system began using sequences as instructions. Suddenly, meaningless correlation became:"]
           [:ul.bulleted
            [:li
             "\"This codon "
             [:em "causes"]
             " this amino acid to appear\""]
            [:li
             "\"This sequence "
             [:em "causes"]
             " this protein to be built\""]
            [:li
             "\"This mutation "
             [:em "causes"]
             " this phenotype difference\""]]
           [:p
            [:strong "Causation emerged from correlation"]
            ". The same pattern appears everywhere:"]
           [:ul.bulleted
            [:li
             "Economies: Prices correlate with supply/demand → markets exploit them → they become causal signals"]
            [:li
             "Neural networks: Patterns correlate in data → networks learn to exploit them → correlations become operative"]
            [:li
             "Distributed systems: Nodes co-observe events → correlation is exploitable → becomes causal ordering"]
            [:li
             "Datom.world agents: Interpreters respond to stream patterns → patterns become causal triggers"]]
           [:h2 "When Schemas Fail"]
           [:p
            "Before examining what Datom.world does differently, let's look at concrete scenarios where "
            "the structure-as-semantics model breaks down:"]
           [:p [:strong "Semantic Evolution"]]
           [:p
            "Schemas ossify. Once you define a structure, changing it requires migration. Every consumer "
            "must update. In large distributed systems, this is intractable."]
           [:p
            "With external interpreters, semantics can evolve independently. Old agents keep running old "
            "interpretations. New agents adopt new ones. The same stream supports both during transition."]
           [:p [:strong "Multiple Perspectives"]]
           [:p
            "A sales team views customer data as leads and conversions. A support team views the same data "
            "as tickets and satisfaction scores. A finance team views it as revenue and churn."]
           [:p
            "One schema cannot capture all perspectives. Forcing a unified ontology means either:"]
           [:ul.bulleted
            [:li
             "Bloating the schema with every perspective (becomes unmaintainable)"]
            [:li
             "Privileging one perspective and marginalizing others (political problem)"]]
           [:p
            "External interpreters solve this. Each team runs its own agent that observes the stream and "
            "extracts its needed semantics. The stream remains minimal; interpretation is pluralistic."]
           [:p [:strong "AI Agent Collaboration"]]
           [:p
            "Future systems will have dozens of AI agents collaborating. Each agent has different goals, "
            "different training, different context. They cannot share a single schema."]
           [:p
            "They need a shared "
            [:em "substrate"]
            " (the stream) with heterogeneous "
            [:em "semantics"]
            " (each agent's interpreter). This is what Datom.world enables."]
           [:h2 "What Datom.world Does Better"]
           [:h3 "Semantic Benefits"]
           [:p [:strong "Dynamic Semantics"]]
           [:p
            "Instead of freezing semantics into schemas, Datom.world makes semantics a runtime phenomenon. "
            "Interpreters are mobile continuations that can evolve, migrate, and observe streams differently. "
            "This supports semantic drift, multiple interpretations, and agent autonomy."]
           [:p
            "Schemas cannot capture everything. Real systems evolve. Semantics drift. AI agents need "
            "dynamic interpretation. Runtime semantics isn't a bug. It's reality."]
           [:p [:strong "Multi-Agent Ecosystem"]]
           [:p
            "Because semantics is external ("
            [:a {:href "/datomworld.chp#axiom-5"} "Axiom 5"]
            "), multiple agents can observe the same stream and "
            "extract different meanings. Essential when AI agents, humans, and systems collaborate. "
            "No single interpretation needs to dominate."]
           [:h3 "Architectural Benefits"]
           [:p [:strong "Distributed Computation"]]
           [:p
            "Built on π-calculus + continuations + streams. Dynamic topology. Programs are agents that move, "
            "observe, emit datoms. Distributed computation is native. Every process can append without coordination "
            "("
            [:a {:href "/datomworld.chp#axiom-3"} "Axiom 3"]
            "), enabling entangled nodes, migratable agents, and interpretation-as-flow."]
           [:p
            "This is a true concurrent model where semantics can run at multiple boundaries: kernel, network, "
            "WASM, yin.vm, or app layer. No static system can match this dynamism."]
           [:p [:strong "Local-First Architecture"]]
           [:p
            "Works offline. Survives partitioning. Operates across heterogeneous networks (BLE, ad-hoc mesh). "
            "No global schema, no global clock, no global truth. Local-first with eventual coherence via "
            "entangled transactors."]
           [:p
            "This aligns with the Web's future: local-first + AI agent autonomy + P2P."]
           [:h3 "Theoretical Foundation"]
           [:p "The model is deeper and unifies:"]
           [:ul.bulleted
            [:li "AI agents"]
            [:li "Distributed operating systems"]
            [:li "Data interoperability"]
            [:li "App runtimes"]
            [:li "Semantic layers"]
            [:li "WASM portability"]
            [:li "Process mobility"]]
           [:p
            "It's closer to how biological, economic, and quantum systems actually work. "
            "The wavefunction has no intrinsic meaning. Meaning arises when an observer interacts with it. "
            "A datom "
            [:code "[e a v t c]"]
            " has no semantics until an agent observes it and imposes meaning."]
           [:h2 "Convergence: What Both Approaches Can Learn"]
           [:p
            "The schema approach isn't wrong—it's incomplete. Rather than viewing these as competing philosophies, "
            "we can see them as complementary strategies that converge on similar goals from different starting points. "
            "Here's where Datom.world can borrow the best aspects of structural approaches without compromising its foundation:"]
           [:p [:strong "Clear Onboarding"]]
           [:p
            "Structure helps. Humans like structure. FirstCognition focuses on making data editing comfortable "
            "with beautiful, rigid UI for collaborative data modeling. Easy mental model: \"it's like Notion, "
            "but typed and structured.\""]
           [:p
            "Datom.world's \"app as interpreter of stream\" model is more powerful, but less immediately obvious. "
            "Investment in polished templates, clean onboarding, and examples for common semantic patterns "
            "(CRM, inventory, logs, tasks) would lower the entry barrier."]
           [:p [:strong "Visual Metaphors"]]
           [:p
            "Dynamic streams + continuations can feel abstract. Visual representations that help non-engineers "
            "create structured streams or template datoms would make the system more approachable."]
           [:p [:strong "Optional Light Ontologies"]]
           [:p
            "Structure helps federation. Datom.world can offer optional schema suggestions, optional "
            "\"light ontologies,\" optional typed helpers. Not required, just helpful. They provide consistency "
            "without forcing semantics."]
           [:p
            "This doesn't compromise the model. Schemas and types are still interpreters under the hood. "
            "But packaging them as \"helpful constraints\" rather than \"required structure\" maintains "
            "the flexibility while reducing foot-guns."]
           [:p [:strong "Packaging Deep Theory"]]
           [:p
            "FirstCognition packages ideas as a collaborative tool rather than as a grand unifying theory. "
            "Datom.world can create accessible entry points, small demos, simple \"recipes,\" quick wins."]
           [:p
            "The depth is a strength, but it needs clear packaging. Users don't need to understand π-calculus "
            "to benefit from mobile continuations. They don't need to grasp quantum mechanics to appreciate "
            "that meaning emerges from observation."]
           [:h2 "Scaling and Interoperability"]
           [:p
            "Schema approaches assume centralization via cloud. A shared structural ontology is enforced. "
            "This works in controlled environments but breaks in heterogeneous, distributed, or adversarial contexts."]
           [:p
            "Datom.world is distributed and entangled by design. Works offline. Survives partitioning. "
            "Works across heterogeneous networks. No reliance on centralized coordination."]
           [:p
            "Optional structure can help. Not as enforcement, but as convention. Datom.world can offer "
            "optional schema suggestions that improve federation without requiring global agreement."]
           [:h2 "The Philosophical Depth"]
           [:p
            "The schema approach says: data as structure → structure as meaning. "
            "Strong on type theory. Weak on dynamic semantics."]
           [:p
            "Datom.world says: meaning emerges from interaction. Continuations as ontology. "
            "Streams as reality substrate. Borrowing from π-calculus, quantum mechanics, stigmergy, "
            "and Taoist metaphors."]
           [:p
            "This isn't metaphor. It's structural correspondence. The way meaning emerges in quantum mechanics "
            "(observer collapses wavefunction) is the same way meaning emerges in Datom.world "
            "(interpreter observes stream). The way biological systems bootstrap (DNA-ribosome loop) "
            "is the same way semantic systems bootstrap (structure-interpreter loop)."]
           [:p "The model is universal. It applies to:"]
           [:ul.bulleted
            [:li "Software (data + interpreter)"]
            [:li "Biology (DNA + ribosome)"]
            [:li "Language (word + speaker)"]
            [:li "Physics (state + observer)"]
            [:li "Economics (currency + participants)"]]
           [:p
            "Everywhere, "
            [:strong
             "causation is stable correlation that persists through time, "
             "and meaning is interpretation of that persistent correlation"]
            "."]
           [:h2 "Practical Implications"]
           [:p
            "This isn't just theory. The choice between structure-as-meaning and interpretation-as-meaning "
            "has concrete consequences:"]
           [:p [:strong "For Data Migration"]]
           [:p
            "Schema approach: migration is painful. Change the schema, update all consumers, coordinate deployment."]
           [:p
            "Datom.world: no migration. Deploy new interpreters. Old ones keep running. Transition is gradual."]
           [:p [:strong "For API Versioning"]]
           [:p
            "Schema approach: versioned APIs (v1, v2, v3). Each version is a maintenance burden. Deprecation is fraught."]
           [:p
            "Datom.world: append-only streams. Interpreters decide which datoms to observe. Old agents ignore new attributes. "
            "New agents process everything. No API versioning needed."]
           [:p [:strong "For Collaboration"]]
           [:p
            "Schema approach: teams negotiate shared ontology. Political. Slow. Compromises everyone."]
           [:p
            "Datom.world: teams run independent interpreters. Shared substrate, heterogeneous semantics. "
            "Each team gets what it needs without blocking others."]
           [:p [:strong "For AI Integration"]]
           [:p
            "Schema approach: AI must conform to the schema. Brittle. Limits what AI can learn."]
           [:p
            "Datom.world: AI agents are just interpreters. They observe streams, form hypotheses, "
            "test predictions. No schema to constrain them. They evolve their own semantics through interaction."]
           [:h2 "Why Schemas Feel Safe (But Aren't)"]
           [:p
            "Schemas feel safe because they're explicit. You can see the structure. You can validate it. "
            "You can generate documentation from it."]
           [:p
            "But that safety is an illusion in complex systems. Schemas work in controlled environments with:"]
           [:ul.bulleted
            [:li "Single authority (one team, one company)"]
            [:li
             "Slow evolution (requirements change yearly, not daily)"]
            [:li
             "Homogeneous consumers (everyone runs the same version)"]]
           [:p
            "Once any of those conditions breaks (distributed authority, rapid evolution, heterogeneous consumers), "
            "schemas become anchors, not safety nets."]
           [:p
            "The real safety comes from "
            [:strong "isolation and contracts"]
            ". In Datom.world:"]
           [:ul.bulleted
            [:li "Streams are append-only (isolation of writes)"]
            [:li "Agents are sandboxed (isolation of execution)"]
            [:li "Interpretation is external (isolation of semantics)"]
            [:li "Tests guard contracts, not schemas"]]
           [:p
            "This provides safety through boundaries, not through central control."]
           [:h2 "The Middle Path"]
           [:p
            "The argument isn't \"schemas are bad.\" It's: "
            [:strong
             "schemas are interpreters, and pretending they're not leads to brittleness"]
            "."]
           [:p
            "Datom.world can embrace schemas as "
            [:em "one kind of interpreter"]
            ":"]
           [:ul.bulleted
            [:li
             "Optional schema validators (agents that observe streams and check conformance)"]
            [:li
             "Type assistants (agents that suggest types based on observed patterns)"]
            [:li
             "Migration helpers (agents that rewrite old datom patterns into new ones)"]
            [:li
             "Ontology explorers (agents that visualize semantic relationships)"]]
           [:p
            "These are tools, not foundations. They help where structure helps, without forcing structure "
            "where it hinders."]
           [:h2 "Conclusion"]
           [:p
            "The question \"where does meaning live?\" isn't philosophical indulgence. It determines "
            "whether your system can adapt, evolve, and support multiple perspectives."]
           [:p
            "Structure cannot carry meaning alone. Only interpretation creates meaning. And interpretation "
            "requires an interpreter (whether you call it that or not)."]
           [:p
            "Datom.world is complete because it explicitly treats semantics as a runtime phenomenon carried "
            "by mobile interpreters, not frozen into the shape of bytes."]
           [:p "This is the architecture for:"]
           [:ul.bulleted
            [:li "Distributed systems that survive partitioning"]
            [:li "Multi-agent environments with heterogeneous goals"]
            [:li
             "AI-driven computation that evolves semantics over time"]
            [:li "Local-first systems that work offline"]
            [:li
             "Semantic interoperability without centralized ontologies"]]
           [:p
            "The schema approach offers simplicity and familiarity. Datom.world offers truth and adaptability. "
            "In controlled environments, simplicity wins. In complex, evolving, distributed systems, "
            "truth is the only foundation that holds."]
           [:p
            [:strong
             "Because ultimately: causation is stable correlation that persists through time. "
             "Meaning is interpretation of that persistent correlation by an agent that can exploit it. "
             "Life and computation are what happen when these correlations stabilize and interpreters emerge."]]
           [:hr]
           [:p.footnote
            {:id "footnote-dna"}
            [:sup "†"]
            " The DNA-ribosome analogy is a conceptual metaphor to illustrate the structure-interpreter "
            "relationship, not a claim about precise biological mechanisms. The actual origin of the genetic code "
            "and ribosomal machinery involves complex biochemistry that remains an active area of research. "
            "The key insight (that structure and interpreter can co-evolve through feedback loops) applies across "
            "biological, computational, and semantic systems."]]]])}
