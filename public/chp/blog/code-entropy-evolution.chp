(let [template (load-file "public/chp/template.chp")]
  (clojure.walk/postwalk-replace
   {:template/title "Code as Entropy: Why Good Software Evolves, Not Designed , Datom.World"
    :template/content
    (list
     [:section.blog-article
      [:div.section-inner
       [:article
        [:h1 "Code as Entropy: Why Good Software Evolves, Not Designed"]
        [:div.blog-article-meta "Published Oct 29, 2025 · 10 minute read"]
        [:p
         "What makes code \"good\"? A friend once told me he doesn't know but bad code is code that other developers write. "
         "The joke is funny because it's true,and it's true because every developer has a different mental model. "
         "What's obvious to you is cryptic to me. What's elegant in your head is spaghetti in mine."]
        [:p
         "Most developers will list qualities like readability, maintainability, or elegance. "
         "But these are artifacts of good code, not descriptions of how to achieve it. "
         "They emerge when you follow the right evolutionary process, but they're subjective,"
         "dependent on those differing mental models."]
        [:p
         "The deeper more fundamental question is: "
         [:strong "what makes code capable of change?"]
         " Because requirements always change, and code that can't adapt is dead code."]
        [:p
         "The answer lies in physics. Specifically, in entropy, dependency graphs, and evolution. "
         "Good code isn't designed,it evolves through a dance with entropy."]
        [:p
         "Here's the nuance: " [:strong "all code increases in entropy over time"] ". "
         "This is the 2nd law of thermodynamics and it applies to code too. Like biological cells that maintain internal order while increasing entropy in their environment"
         [:sup [:a {:href "https://www.quantamagazine.org/a-new-thermodynamics-theory-of-the-origin-of-life-20140122/"} "*"]]
         ", good code " [:em "minimizes entropy within each module while increasing entropy of the whole system"] "."]
        [:p
         "This is the key insight of biology and code: distribute complexity outward (more modules, more namespaces) "
         "while keeping each module internally coherent. The system becomes more entropic, but each piece stays organized. "
         "This is what makes biology and code adaptable."]
        [:h2 "The Only Objective Measure: Malleability"]
        [:p
         "Code quality is subjective. What's \"clean\" to one team is obtuse to another. "
         "Shared mental models help (Domain Driven Design attempts this), but teams still disagree."]
        [:p
         "There is, however, one objective standard: "
         [:strong "good code is code that adapts to changing requirements with low cost"]
         ". Bad code is rigid,small changes cascade through the system, forcing rewrites instead of refinements."]
        [:p
         "This isn't about aesthetics. It's about adaptability and survival. Software that can't change dies when the world around it shifts. "
         "Malleability is the only fitness function that matters, it's why we call it \"soft\"ware, not \"hard\"ware."]
        [:h2 "High Cohesion and Loose Coupling: The Core Principle"]
        [:p
         "Kent Beck spent 17 years learning to explain cohesion and coupling"
         [:sup [:a {:href "https://www.infoq.com/news/2022/10/beck-design-human-relationships/"} "†"]]
         ". The principle is simple:"]
        [:ul.bulleted
         [:li [:strong "High cohesion"] " , things that change together should live together"]
         [:li [:strong "Loose coupling"] " , things that change independently should be isolated from each other"]]
        [:p
         "When modules are tightly coupled, a change in one module ripples through all its dependents. "
         "You can't modify behavior without understanding the entire dependency graph. "
         "The cost of change becomes prohibitive."]
        [:p
         "When modules are loosely coupled but internally cohesive, changes are local. "
         "You modify what needs to change without touching anything else. "
         "The system adapts without rewriting."]
        [:p
         "This is measurable. Draw your dependency graph. If it looks like spaghetti, your code is rigid. "
         "If it looks like cleanly separated clusters with minimal cross-connections, your code can evolve."]
        [:h2 "Why Spaghetti Code is the Default State"]
        [:p
         "By analogy to statistical mechanics: "
         [:strong "there are more ways to write tightly coupled code than loosely coupled code"]
         "."]
        [:p
         "Every function you write creates potential dependencies. "
         "Without deliberate effort, those dependencies accumulate randomly. "
         "The probability space of \"spaghetti architectures\" vastly exceeds the probability space of \"clean architectures.\""]
        [:p
         "This is entropy at work. In information theory, entropy measures how many bits of information you need to describe a state. "
         "A high-entropy system has many degrees of freedom,many possible configurations,requiring more information to specify exactly what's happening."]
        [:p
         "In code: high entropy means a programmer needs more bits in their head to understand the system, tracking not just the static structure but the runtime behavior, and more code to describe its state. "
         "Tight coupling (spaghetti) has vastly more possible configurations than loose coupling (clean layers). "
         "Without deliberate effort, systems drift toward high entropy simply because there are more ways to be messy than organized."]
        [:p
         "This is why high-entropy code is easier to write but harder to read and change. "
         "Writing tightly coupled code requires no planning, dependencies form naturally as you reach for whatever function you need. "
         "But reading it requires reconstructing all those implicit connections in your head. "
         "And changing it means tracing ripple effects through the tangled web."]
        [:p
         "Additionally, premature naming constrains your design. When you name a module before you understand its boundaries, "
         "you lock in assumptions. Structure should guide naming, not the other way around."]
        [:p
         "Example: You create a " [:code "user-service"] " namespace early in the project. "
         "Later you realize some functions deal with authentication, others with profiles, others with permissions. "
         "But the name " [:code "user-service"] " doesn't reflect these distinctions. Now you face a choice:"]
        [:ul.bulleted
         [:li "Refactor into " [:code "auth"] ", " [:code "profiles"] ", and " [:code "permissions"]
          " (correct but requires renaming and moving code)"]
         [:li "Keep everything in " [:code "user-service"] " (easy but hides the real structure)"]]
        [:p
         "The premature name created resistance to the right structure. If you'd started with " [:code "core"]
         " or " [:code "users"] " and let the cohesive clusters emerge, "
         "the structure would have guided you toward " [:code "auth"] ", " [:code "profiles"] ", and " [:code "permissions"]
         " naturally."]
        [:p
         "Frameworks like Ruby on Rails make this worse by forcing everything into MVC: models, views, controllers. "
         "This is " [:strong "solution domain vocabulary"] ", not " [:strong "problem domain vocabulary"] ". "
         "Your e-commerce app doesn't naturally think in \"controllers\",it thinks in orders, payments, inventory, shipping. "
         "But Rails forces you to organize by technical pattern instead of business concept."]
        [:p
         "The result: " [:code "OrdersController"] ", " [:code "PaymentsController"] ", " [:code "InventoryController"]
         ",where the suffix \"Controller\" adds no information and the real domain concepts (orders, payments, inventory) "
         "are buried in a solution-domain structure. You've let the framework name your modules before you understand the problem."]
        [:h2 "Entropy in Software: Distribute to Organize"]
        [:p
         "Entropy is often described as \"disorder,\" but that's vague. In information theory, "
         [:strong "entropy measures how many bits of information you need to describe a state"] "."]
        [:p
         "A high-entropy system requires more information to specify what's happening. In code, this translates to:"]
        [:ul.bulleted
         [:li [:strong "More bits in your head"] " , higher cognitive load to build a mental model"]
         [:li [:strong "More code to describe state"] " , verbose, scattered logic"]
         [:li [:strong "More files to read"] " , understanding requires jumping through many namespaces"]]
        [:p
         "Here's a concrete measure: " [:strong "how many files must you open to understand or modify a feature?"]
         " If you need to read 10 scattered files, that's high entropy,you need a lot of context (information) to reconstruct what's happening. "
         "If one cohesive module contains everything, that's low entropy,all the information is localized."]
        [:p
         "This is why high-entropy code is hard to understand: it demands more information to describe, creating cognitive overload."]
        [:p
         "The solution is counterintuitive: "
         [:strong "increase system entropy while decreasing module entropy"]
         "."]
        [:p
         "Start with a single namespace containing all your code. As it grows, identify cohesive clusters,"
         "groups of functions that change together. Extract them into separate namespaces. "
         "Repeat as the system evolves."]
        [:p
         "This increases system entropy (more namespaces, more distribution) while decreasing module entropy "
         "(each namespace is internally coherent). The result is a codebase where structure emerges naturally "
         "rather than being imposed prematurely."]
        [:pre
         [:code {:class "language-clojure"}
";; Phase 1: Everything in one namespace
(ns myapp.core)

(defn fetch-user [id] ...)
(defn save-user [user] ...)
(defn validate-email [email] ...)
(defn send-notification [user] ...)

;; Phase 2: Cohesion emerges, extract clusters
(ns myapp.users)
(defn fetch [id] ...)
(defn save [user] ...)

(ns myapp.validation)
(defn email [email] ...)

(ns myapp.notifications)
(defn send [user] ...)"]]
        [:p
         "Notice: we didn't start with a grand architecture. We let the code tell us where the boundaries are. "
         "This is evolution, not intelligent design."]
        [:h2 "Evolution Requires Selection Pressure: Tests as Fitness Functions"]
        [:p
         "In biology, evolution works because natural selection kills unfit organisms. "
         "In software, evolution works because tests kill unfit code."]
        [:p
         "Without tests, you have no feedback loop. Changes accumulate with no verification. "
         "Code drifts toward rigidity because there's no pressure selecting for malleability."]
        [:p
         "The Clojure REPL is uniquely suited for this. Low-cost experimentation means you can try variations quickly, "
         "observe their behavior, and formalize the winning patterns as tests. "
         "This is adaptive evolution, not waterfall planning."]
        [:pre
         [:code {:class "language-clojure"}
";; In the REPL: experiment
(comment
  (let [user {:email \"invalid\"}]
    (validate-email (:email user)))
  ;; => false, good

  (let [user {:email \"valid@example.com\"}]
    (validate-email (:email user)))
  ;; => true, good

  ;; Formalize as test
  (deftest email-validation
    (is (false? (validate-email \"invalid\")))
    (is (true? (validate-email \"valid@example.com\"))))
)"]]
        [:p
         "Tests create selection pressure. Code that breaks tests doesn't survive. "
         "Code that passes tests with minimal coupling survives and reproduces (gets reused)."]
        [:h2 "The Brittleness Paradox: When Tests Become Technical Debt"]
        [:p
         "But here's the uncomfortable truth: " [:strong "tests have a cost"] ". "
         "The wrong tests make your system " [:em "more"] " rigid, not less."]
        [:p
         "If you test every internal function, you've coupled your tests to your implementation. "
         "Now you can't refactor the internals without rewriting all the tests,even though the module's "
         [:em "behavior"] " (what it promises to the outside world) hasn't changed."]
        [:p
         "This is test-induced brittleness. The tests that were supposed to enable change now prevent it."]
        [:h3 "Test the Contract, Not the Implementation"]
        [:p
         "The solution: " [:strong "only test the interfaces between modules"] "."]
        [:p
         "The interface is where coupling lives. If Module A depends on Module B's interface, "
         "that interface is a promise. Breaking that promise ripples through the system. "
         [:em "That's"] " where you need tests,to ensure promises hold even as implementations evolve."]
        [:p
         "Internal changes within a module? Those should be free to evolve as long as the contract stays intact. "
         "If you have tests for every private helper function, you've made those internals part of the public API "
         "from a testing perspective."]
        [:pre
         [:code {:class "language-clojure"}
";; Bad: Testing internals creates brittleness
(deftest test-internal-parser
  (is (= [:token \"foo\"] (internal-parse-token \"foo\"))))

;; Refactor internal-parse-token? You have to update this test.
;; Even though the PUBLIC behavior didn't change.

;; Good: Test the public contract
(deftest test-parse-api
  (is (= {:tokens [\"foo\" \"bar\"]}
         (parse \"foo bar\"))))

;; Refactor internal functions freely.
;; As long as parse/1 returns the right shape, the test passes."]]
        [:p
         "This is the art of testing: identifying where the true coupling boundaries are and guarding those, "
         "not the implementation details."]
        [:h3 "The Knowledge Preservation Problem"]
        [:p
         "But if you don't test internals, how do you understand them when you need to modify the module?"]
        [:p
         "I encountered this on a project. The lead engineer had a philosophy: \"Test only external contracts, "
         "not internal implementation details.\" Sound reasoning. But then they added constraints:"]
        [:ul.bulleted
         [:li "All non-public functions must be marked " [:code "defn-"] " (private)"]
         [:li "No committed " [:code "(comment ...)"] " blocks with REPL experiments"]
         [:li "No internal tests in separate directories"]]
        [:p
         "The result? Every time I had to modify something in a module, I had to write throwaway REPL tests "
         "to understand the internals, then delete them. The next person (including future me) would have to "
         "rediscover the same edge cases, the same assumptions, the same behavior."]
        [:p
         "We were paying the exploration cost repeatedly instead of amortizing it across the team."]
        [:h3 "The Middle Path: Comment Blocks as Ephemeral Knowledge"]
        [:p
         "The solution isn't to test everything. It's to preserve knowledge without coupling to implementation."]
        [:p
         [:strong "Commit " [:code "(comment ...)"] " blocks with REPL experiments"] ". "
         "These aren't tests,they're ephemeral documentation. They show:"]
        [:ul.bulleted
         [:li "How the module's internals work"]
         [:li "What edge cases exist"]
         [:li "What assumptions the author made"]
         [:li "How to quickly verify behavior during changes"]]
        [:p
         "But here's the critical part: " [:strong "comment blocks decay"] ". "
         "Code evolves. Function signatures change. Edge cases get handled differently. "
         "Assumptions that were true yesterday become false today."]
        [:p
         "Unlike automated tests that fail in CI when they're wrong, comment blocks silently rot. "
         "They become lies,misleading the next person who runs them."]
        [:p
         [:strong "The cultural solution: delete ruthlessly when they lie"] "."]
        [:p
         "Don't try to maintain every comment block perfectly. That's as expensive as maintaining tests "
         "without the benefit of automation. Instead:"]
        [:ul.bulleted
         [:li "Write comment blocks while developing to clarify thinking"]
         [:li "Commit them,they're valuable while accurate"]
         [:li [:strong "When someone finds they lie, delete them"] " (don't fix, just delete)"]
         [:li "The ones that survive are the ones that keep reflecting reality"]]
        [:p
         "This creates natural selection for documentation. Comment blocks have value while they're true. "
         "When they're false, the cost of deletion is lower than the cost of maintenance. "
         "The team culture enforces it: " [:em "\"If it's wrong, delete it. Don't leave lies.\""]
         "."]
        [:pre
         [:code {:class "language-clojure"}
"(defn- parse-tokens
  \"Internal: splits input into tokens. Handles empty input gracefully.\"
  [input]
  (if (empty? input)
    []
    (str/split input #\"\\s+\")))

(comment
  ;; Exploration from 2024-10-15
  ;; If you find these examples don't work, DELETE this block

  (parse-tokens \"foo bar baz\")
  ;; => [\"foo\" \"bar\" \"baz\"]

  (parse-tokens \"\")
  ;; => []

  (parse-tokens \"  extra   spaces  \")
  ;; => [\"extra\" \"spaces\"]

  ;; Edge case: leading/trailing spaces are stripped
)

;; Three months later, someone refactors parse-tokens to return maps:
;; They run the comment block, see it's wrong, and DELETE it.
;; No guilt. No maintenance burden. Just removal."]]
        [:p
         "Future you (or a teammate) can run these in the REPL to quickly understand how the function behaves. "
         "When the examples stop working or become misleading, delete the entire comment block. "
         "No guilt. No heroic maintenance. Just ruthless culling of stale knowledge."]
        [:h3 "All Documentation Decays"]
        [:p
         "It's tempting to think prose documentation is safer than runnable examples. It's not. "
         "Prose rots just as fast,maybe faster, because you can't run it to verify it's still true."]
        [:p
         "The docstring that says \"Returns a vector\" becomes a lie when you refactor to return a map. "
         "The comment that says \"Handles nil gracefully\" becomes misleading when you change the nil-handling behavior. "
         "The README that explains the architecture becomes obsolete when you restructure the codebase."]
        [:p
         "All documentation has a half-life. The question isn't how to prevent decay,it's "
         [:strong "how to make decay cheap to handle"] "."]
        [:p
         "Options:"]
        [:ol
         [:li [:strong "Automate it"] " , Tests fail in CI when wrong. High cost to maintain, but failures are visible."]
         [:li [:strong "Delete it"] " , Comment blocks deleted when wrong. Low cost, but you lose knowledge."]
         [:li [:strong "Accept it"] " , Prose documentation decays silently. Lowest maintenance cost, highest confusion cost."]]
        [:p
         "There's no perfect answer. Just different tradeoffs. The key is choosing consciously based on what you're optimizing for."]
        [:h3 "When to Test Internals (Temporarily)"]
        [:p
         "Sometimes a module is complex enough that you need confidence in its internals while building it. "
         "In those cases, write tests as " [:em "scaffolding"] ":"]
        [:ol
         [:li "Write internal tests to clarify logic and explore edge cases"]
         [:li "Use them to validate assumptions during development"]
         [:li [:strong "Delete or demote them"] " once the module stabilizes, keeping only interface tests"]]
        [:p
         "Or better yet: if a function is complex enough to need permanent testing, extract it into "
         "its own module with a tested public interface. Complexity often signals unclear boundaries."]
        [:h3 "The Real Fitness Function"]
        [:p
         "The measure isn't \"how many tests do you have.\" It's: "
         [:strong "how cheaply can you change without breaking promises?"]
         "."]
        [:p
         "Test the contracts between modules. Preserve exploration knowledge in comment blocks. "
         "Let internals evolve freely. The system stays malleable because tests guard promises, not implementation."]
        [:h2 "The Central Question: Do You Need to Understand to Modify?"]
        [:p
         "Here's a provocative claim: "
         [:strong "good architecture reduces the cognitive burden required to make changes safely"]
         "."]
        [:p
         "You don't always need to understand the entire system to modify part of it. "
         "If your modules are loosely coupled, you can change one without deeply understanding the others. "
         "The dependency graph protects you."]
        [:p
         "Bad architecture forces you to understand everything before changing anything. "
         "The spaghetti graph means modifications in one place might break something three layers away. "
         "You need a complete mental model just to make a one-line fix."]
        [:p
         "Good architecture isolates risk. Change is local. Understanding is bounded. "
         "The system is malleable because the cost of modification stays low."]
        [:h2 "Practical Workflow: From Chaos to Structure"]
        [:p
         "Here's the process distilled:"]
        [:ol
         [:li [:strong "Start messy"] " , Write everything in one namespace. Don't prematurely organize."]
         [:li [:strong "Experiment in the REPL"] " , Use " [:code "(comment ...)"] " blocks to explore behavior and discover edge cases."]
         [:li [:strong "Observe cohesion"] " , As code grows, notice which functions change together."]
         [:li [:strong "Extract clusters"] " , Move cohesive groups into separate namespaces."]
         [:li [:strong "Minimize coupling"] " , Reduce dependencies between namespaces."]
         [:li [:strong "Test interfaces"] " , Write tests for the contracts between modules, not internal implementation details."]
         [:li [:strong "Commit comment blocks"] " , Preserve REPL experiments as runnable documentation for future maintainers."]
         [:li [:strong "Iterate"] " , Repeat as requirements change."]]
        [:p
         "This isn't top-down design. It's bottom-up evolution guided by feedback loops. "
         "Structure emerges from observing the system's natural boundaries."]
        [:h2 "Dependency Graphs: Seeing Quality Without Understanding the Code"]
        [:p
         "Here's a remarkable property of dependency graphs: "
         [:strong "you can assess code quality by visual inspection alone, without understanding the code or the domain"]
         "."]
        [:p
         "A good dependency graph looks " [:em "layered"] ",clean separation between modules, minimal cross-connections, "
         "clear flow from low-level primitives to high-level features. You can see the structure at a glance."]
        [:p
         "A bad dependency graph looks like " [:em "spaghetti"] ",dense tangles, circular dependencies, "
         "everything connected to everything. The visual chaos reflects the architectural chaos."]
        [:p
         "This is objective. You don't need to read a line of code. The graph shape tells you:"]
        [:ul.bulleted
         [:li [:strong "Spaghetti (densely tangled)"] " → changes cascade everywhere, rigid code, high coupling"]
         [:li [:strong "Layered (clean strata)"] " → changes are local, malleable code, loose coupling"]
         [:li [:strong "Clustered (islands with bridges)"] " → cohesive modules with minimal inter-module dependencies"]]
        [:p
         "Tools like " [:code "lein-ns-dep-graph"] " (Clojure), " [:code "madge"] " (JavaScript), or "
         [:code "pydeps"] " (Python) can generate these visualizations. "
         "The graph doesn't lie,tight coupling is visible as tangled edges, loose coupling as clean separation."]
        [:p
         "Use this as your fitness metric. If the graph is improving (clearer layers, fewer tangles), "
         "your code is evolving toward health. If it's degrading (more tangles, circular dependencies), "
         "you're accumulating technical debt."]
        [:p
         "The beauty: you can review a PR's dependency graph changes without understanding what the code does. "
         "Does it add more tangles or clean up the structure? The visual tells the story."]
        [:h2 "Why This Matters for Datom.World"]
        [:p
         "Datom.World is built on these principles:"]
        [:ul.bulleted
         [:li [:strong "Streams as universal primitives"] " , Everything is a datom stream. High cohesion around the stream abstraction, loose coupling between components that consume streams."]
         [:li [:strong "Continuations as mobile computation"] " , Yin isolates execution contexts. Each continuation is a cohesive unit that doesn't couple to the host environment."]
         [:li [:strong "Two-function API"] " , " [:code "read"] " and " [:code "write"] " minimize the coupling surface. Fewer dependencies mean easier evolution."]
         [:li [:strong "Entangled nodes, not monoliths"] " , Distributed entropy (many nodes) with local coherence (each node maintains low internal entropy)."]
         [:li [:strong "Test the boundaries, not the implementation"] " , We test the stream API (" [:code "read"] "/" [:code "write"] "), the Yin sandbox isolation guarantees, and WireGuard tunnel establishment,the contracts that define trust. Internal implementation details evolve freely."]]
        [:p
         "We apply the same evolutionary pressure to our codebase: start simple, let structure emerge through REPL exploration, "
         "test interfaces not implementations, preserve knowledge in comment blocks, and refactor toward malleability. "
         "The dependency graph stays clean because we actively resist entropy."]
        [:h2 "Conclusion: Code That Breathes"]
        [:p
         "Good code isn't a static artifact. It's a living system that evolves in response to changing requirements. "
         "The measure of goodness is malleability,can it adapt with low cost?"]
        [:p
         "High cohesion and loose coupling provide the structure. Entropy guides the distribution. "
         "Interface tests provide the selection pressure,guarding promises, not implementations. "
         "Comment blocks preserve ephemeral knowledge,valuable while true, deleted when they lie. "
         "Dependency graphs reveal quality at a glance,layered structure vs. tangled spaghetti, visible without understanding the code."]
        [:p
         "The result is code that breathes: expanding when needed, contracting when simplified, "
         "always adapting to the environment around it."]
        [:p
         "This is software as evolution, not intelligent design. And evolution, given enough time and the right pressures, "
         "produces remarkably resilient systems."]
        [:p [:strong "Further reading:"]]
        [:ul.bulleted
         [:li "Kent Beck's work on coupling and cohesion (he spent 17 years learning to explain it)"]
         [:li "Rich Hickey's talks on simplicity, especially \"Simple Made Easy\""]
         [:li [:a {:href "https://www.quantamagazine.org/a-new-thermodynamics-theory-of-the-origin-of-life-20140122/"}
          "A New Thermodynamics Theory of the Origin of Life"]
          " , Quanta Magazine , on how systems maintain low entropy by increasing entropy in their environment"]
         [:li [:a {:href "https://lambdakids.stigmergy.systems/2024/5/26/good-code.blog"} "What is Good Code?"]
          " , the statistical mechanics argument and dependency graphs"]
         [:li [:a {:href "https://lambdakids.stigmergy.systems/2022/10/1/locality-cohesion-coupling-entropy-software.blog"}
          "Locality, Cohesion, Coupling, Entropy, and Evolution in Software"]
          " , the original essays this post synthesizes"]]
        ]]])}
   template))
